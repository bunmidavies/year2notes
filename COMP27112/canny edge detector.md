[[COMP27112]]

### intro + requirements
- the canny edge detector was proposed by John F. Canny in 1986 - he stated 3 main ==requirements== for edge detection:
	1. detect as many edges as possible without falsely detecting edges
	2. an edge point detected by the operator should accurately localise on the centre of the edge
	3. a given edge in the image should only be marked once (single pixel marking)
- canny edge detection has a high level of accuracy as well as performance, and does well with detecting weak edges, which other methods may not be as good at doing

### canny edge algorithm summary
- to summarise the steps below:
	1. smooth the input using a ==gaussian filter== ([[noise + smoothing]])
	2. compute the gradient magnitude and direction images (stored in $\theta(x,y)$)
	3. apply non-maxima suppression i.e. ==edge thinning== to the magnitude image
	4. have a high and low threshold to detect and link the final edges

### full canny edge algorithm
1. ==Kernel creation + Smoothing + Edge detection==
- the first part of canny edge detection involves creating a gaussian smoothing kernel, $G(x,y)$ ([[noise + smoothing]])
- the image in question is then convolved with this kernel to get a smoothed image
- this image can then have [[edge detection]] applied with any operator, and the gradient magnitude / direction for each pixel can be calculated (edge normals)

2. ==Edge normal operations==
- the edge normals are classified into 1 of 4 categories, based on the edge direction:
	1. horizontal edge (0/180)
	2. vertical edge (90/-90)
	3. 45$\degree$ edge (135/-45)
	4. -45$\degree$ edge (45/-135)
- the edge normals are given one of those specific values based on where it lies, so that now the image only has edge normals going in one of those specific directions
- these directions can be stored somewhere, in the lectures this is referred to as $\theta(x,y)$
![ | 300](https://i.imgur.com/Xe3E3LQ.png)

3. ==Non-maxima suppression==
- also known as edge thinning, this process ensures the 3rd requirement made by John Canny
- a new image must be created to store the result (as this process cannot be done in-place)
- for each pixel in the image generated by the last step, find its direction (in $\theta(x,y)$), as well as the direction of its 8 neighbouring pixels
- if 2+ neighbouring pixels are in the same direction ==and== have a higher magnitude, the value of the current pixel becomes 0
- otherwise, leave the pixel value as is

4. ==Thresholding==
- have two thresholds $T_L$ and $T_H$, and classify pixels from the thinned out image (created in step 3) as follows:
	- magnitude $\lt T_L$ = ==not an edge==
	- $T_L \lt$ magnitude $\lt T_H$ = ==weak edge==
	- magnitude $\gt T_H$ = ==strong edge==
- two binary images for the strong and weak edges can be created (pretty straightforward to do, just make weak everything > $T_L$, strong everything $\gt T_H$, and make weak = weak - strong)
- note that Canny suggested that $T_H$ should be 2-3 times $T_L$

5. ==Final step==
- assume all the pixels in the strong edge image are valid edge pixels
- for pixel which isn't 0 in the strong image:
	- if any of its neighbours in the weak image are set, then set those pixels in the strong image
- now, ==this strong image is the result of canny edge detection==