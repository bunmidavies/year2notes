[[COMP26020]]

### ~ intro + definition
- the middle-end of a compiler performs error checking / optimisations on the already intermediate-level representation returned from [[semantic analysis]], in order to end up with a ==convenient== intermediate representation
- an internal representation which can represent the code is required, but an internal representation which can also capture ==properties== of the code that can be useful for analysis is also helpful
- this intermediate representation can be stored in a number of ways - the main reason we want an IR rather than just using a parse tree from [[syntactic parsing]] is that parse trees store a lot of unnecessary info

### ~ types of IR (intermediate representation)
- there are a number of different categories of IRs, differing in structure in order to represent code
	- ==Graphical== (structural) e.g. trees: this representation is close to the source code, but node / edge structures tend to be large
	- ==Linear== e.g. pseudocode for some abstract machine: large variation in size, but close to target code
	- ==Hybrid==: a combination of graphical and linear
- ==there is no universally good choice for an IR - it all depends on the compilers goals==

### ~ abstract syntax trees (AST)
- an abstract syntax tree takes the parse tree which contained a lot of unnecessary info, and removes that info to return a near source-level representation
- the source code can be generated by performing an ==inorder tree traversal== ([[tree traversal]])

### ~ three-address code / two-address code / one-address code
- three-address code is a linear type of IR - each statement within three-address code has:
	- 1 single operator 
	- at most 3 operands
- the advantage of this is ==compactness==, and that this machine code like representation can be easily optimised / transformed
- two-address code and one-address code are the same idea, just having less operands
- as you decrease the number of operands, you increase the compactness of the code - for instance one-address code (also called stack machine code) can be useful in environments where very little space is available

### ~ auxilary graph representations
- auxilary representations are useful for capturing ==properties of code== (but not all of it) - this can be useful for performing certain optimisations or analysis on the code
- the following can be useful:
	- ==control-flow graph (CFG)==: models the how the program transfers control (from conditional / loop statements) - a node is some line of code, an edge is a transfer of control
	- ==data dependence graph==: models the flow of data within a program
	- ==call graph==: shows dependences between procedures in a program

### ~ high level code optimisations
- once an IR is in place, the compiler can try to apply a series of optimising transformations, with the goal of improving program performance
- the following points must be kept in mind while this takes place:
	- ==legality== - must preserve the meaning of the program
	- ==benefit== - must improve performance on average or common cases
	- ==compile time== - the time taken to perform these optimisations must be justified
- compiler optimisation is complex, and the optimising transformations which take place may also need to be ordered appropriately
- typical transformations include:
	- discovering / propagating some constant value
	- removing unreachable / redundant computations
	- encoding a computation in a particularly efficient form

### ~ classifying optimsiations
- there are 3 main ways to classify optimisations which a compiler performs:
	- ==by scope== - the scope in which the optimisation takes place can for instance be on a local level, a loop level, a global level, or interprocedural level
	- ==by machine information used== - the optimisation may be machine-independent (high level) or machine dependent
	- ==by program structure effect== - the optimisation could be just an algebraic transformation, or reorder computations themselves

### ~ example transformations
- some example optimisation transformations which a compiler may perform (*middle-end slides 23/24*)
![ | 450](https://i.imgur.com/5DzXp9Y.png)
![ | 450](https://i.imgur.com/M442Hj2.png)
